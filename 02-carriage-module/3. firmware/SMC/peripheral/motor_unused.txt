	if ((DC->countE - DC->countBE) * (DC->dir ? 1 : -1) == 1) {
		DC -> speedE = DC->tim - timB;

		DC -> countBE = DC -> countE;
		timB = DC -> tim;
	}

	if (spd < DC->countE) spd = DC->countE;

	if (!(DC -> tim % 240)) {
		DC -> speedE = abs(DC->countBE - DC->countE);
		DC -> countBE = DC -> countE;

//		if (first++ == 2) {
//			spd = DC -> speedE;
//			spdFlag = 1;
//		}
	}


int32_t lastCountE1 = 0;
int32_t lastCountE2 = 0;
int32_t lcE1 = 0;
int32_t lcE2 = 0;
uint8_t flagE1 = 0;
uint8_t flagE2 = 0;
void DC_Move(uint8_t id, uint8_t duty, uint32_t counts, uint8_t dir, uint8_t exc) {
	DCM *DC;
	id ? DC = &DCR : DC = &DCL;

	HAL_GPIO_WritePin(DC -> OUT_PORT, DC -> OUT_PIN, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(DC -> IN_PORT, DC -> IN_PIN, GPIO_PIN_RESET);

	if (!DC -> is_running) {
		DC -> counts_to_go = dir ?	(DC->countE + counts):
									(DC->countE - counts);
		DC -> counts_going = counts;

		DC -> duty = duty;
		DC -> dir = dir;
		DC -> is_running = 1;

		DC -> compFlag = exc;
		DC -> diag = 0;
		DC -> tim = 0;

		if (counts < 120) DC -> brakeCapa = 0;
		else if (counts <= 150) DC -> brakeCapa = lv[id][0];
		else if (counts <= 300) DC -> brakeCapa = lv[id][1];
		else if (counts <= 500) DC -> brakeCapa = lv[id][2];
		else DC -> brakeCapa = lv[id][3];

		DC -> countBE = DC -> countE;
		DC -> speedE = 0;
		if (id) {
			sSpeedE2 = 0;
			flagE2 = 0;
			lastCountE2 = DC -> countE;
		} else {
			sSpeedE1 = 0;
			flagE1 = 0;
			lastCountE1 = DC -> countE;
		}

		HAL_TIM_Base_Start_IT(DC -> htim_dc);
	}
}

void DC_TIM_Interrupt(DCM *DC) {
	DC -> count++; DC -> tim++;
	if(DC -> count  >= DC -> period) DC -> count = 0;

	if (DC -> count < DC -> duty) HAL_GPIO_WritePin(DC -> dir ? DC -> OUT_PORT : DC -> IN_PORT,
		DC -> dir ? DC -> OUT_PIN : DC -> IN_PIN, GPIO_PIN_SET);
	else HAL_GPIO_WritePin(DC -> dir ? DC -> OUT_PORT : DC -> IN_PORT,
		DC -> dir ? DC -> OUT_PIN : DC -> IN_PIN, GPIO_PIN_RESET);

	if (DC -> is_running) {
		abs_error = abs(DC->counts_to_go - DC->countE);

		if (abs_error <= DC->speedE*DC->brakeCapa/100 &&
						(DC->counts_going >= 120 ? DC->speedE >= 10 : 1))
			DC_Stop(DC -> id);

		if (DC -> compFlag && (DC->countE < DC_MIN || DC_MAX < DC->countE))
			DC_Stop(DC -> id);
//		if (DC -> dir ? ctg >= DC -> counts_to_go:
//				 		ctg <= DC -> counts_to_go) {
//			DC_Stop(DC -> id);
//		}
	}

	if (DC -> tim == 800) {
		if (DC -> id) {
			DC -> speedE = abs(DC->countE - lastCountE2);
			lastCountE2 = DC -> countE;
		} else {
			DC -> speedE = abs(DC->countE - lastCountE1);
			lastCountE1 = DC -> countE;
		}

		DC -> tim = 0;
		DC -> id ? flagE2++ : flagE1++;
	}

	if (!(DC -> tim % 80)) {
		if (DC -> id) {
			sSpeedE2 = abs(DC->countE - lcE2);
			lcE2 = DC -> countE;
		} else {
			sSpeedE1 = abs(DC->countE - lcE1);
			lcE1 = DC -> countE;
		}
	}

	if ((DC -> id ? flagE2 : flagE1) > 30 && (DC -> id ? sSpeedE2 : sSpeedE1) < 3) {
		DC -> diag = 1;
		DC_Stop(DC -> id);
	}
}